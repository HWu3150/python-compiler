# Pythonic Compiler

A Simple compiler to parse python files and build and analyse Python AST.

## Requirements

### Numba Version
This project requires **Numba 0.60.0**. Please ensure you have this specific version installed to avoid compatibility issues.

### Python Interpreter Version
The project is built based on **Python 3.10**, specifically **Python 3.10.12**. Based on my tests, using lower versions of Python leads to discrepancies in the Control Flow Graph (CFG) structure generated by Numba. Additionally, SSA transformation may fail when using different versions of the Python interpreter.

### Important Note
To ensure consistent behavior, it is necessary to use **Python 3.10.12** with Numba 0.60.0. Deviating from these versions may result in unexpected behavior or errors during code execution.

## Run Instruction
To run the program, 3 lines of code need to be executed. The following function is used as an example of how to run the
program.

1. Import necessary packages, functions and variables. Below is what's needed:
```Python
import numpy as np
from numba import njit

from get_ssa_compiler import ssa_by_blocks, blocks, GetSSACompiler, clear, print_ssa
from graph_viz import viz_ast_and_cfg
```

2. Annotated the target function with ```@njit(pipeline_class=GetSSACompiler)``` in order to collect SSA statements and basic blocks.
```Python
# dense matrix vector multiplication
@njit(pipeline_class=GetSSACompiler)
def dense_mv(A, x):
    """
    Perform a dense matrix-vector multiplication.

    Args:
        A: A numpy array representing the matrix.
        x: A numpy array representing the vector.

    Returns:
        The result of the matrix-vector multiplication.
    """
    y = np.zeros(A.shape[0])
    for i in range(A.shape[0]):
        for j in range(A.shape[1]):
            y[i] = A[i, j] * x[j]
    return y
```

3. Clear global variable ```ssa_by_blocks``` and ```blocks```. They are set global because compiler pass cannot store
attributes like objects do.
4. Run the function itself once, since it needs to be compiled for the first time.
5. (Optional) Run ```print_ssa(ssa_by_blocks)``` if you want to inspect the SSA form of the function.
6. Run ```viz_ast_and_cfg(blocks, dense_mv)``` to compute original AST, CFG, and reconstructed AST. In this step, the
three graphs will be rendered and stored under ```dense_mv_visualizations/```.

### Overall, the process is as below:
```Python
import numpy as np
from numba import njit

from get_ssa_compiler import ssa_by_blocks, blocks, GetSSACompiler, clear, print_ssa
from graph_viz import viz_ast_and_cfg


# dense matrix vector multiplication
@njit(pipeline_class=GetSSACompiler)
def dense_mv(A, x):
    """
    Perform a dense matrix-vector multiplication.

    Args:
        A: A numpy array representing the matrix.
        x: A numpy array representing the vector.

    Returns:
        The result of the matrix-vector multiplication.
    """
    y = np.zeros(A.shape[0])
    for i in range(A.shape[0]):
        for j in range(A.shape[1]):
            y[i] = A[i, j] * x[j]
    return y


clear(ssa_by_blocks, blocks)
dense_mv(np.zeros((2, 2)), np.zeros(2))
print_ssa(ssa_by_blocks)
viz_ast_and_cfg(blocks, dense_mv)
```

## Test Files
Several test files are created, each containing one target function. Feel free to run them!

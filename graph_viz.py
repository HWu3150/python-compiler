import ast
import inspect
import graphviz
from graphviz import Digraph
from numba.core.analysis import compute_cfg_from_blocks


def get_ast(func):
    source = inspect.getsource(func)
    tree = ast.parse(source)
    print("AST Tree:", ast.dump(tree, indent=4))
    return tree


def build_ast_graph(node, graph=None, parent=None):
    if graph is None:
        graph = Digraph(comment="AST")

    # context of the node, for example, Store(), Load()
    node.ctx = None

    node_id = str(id(node))
    label = type(node).__name__

    # set node name
    if isinstance(node, ast.Constant):
        label += f"\\n{node.value}"
    elif isinstance(node, ast.Name):
        label += f"\\n{node.id}"
    elif isinstance(node, ast.BinOp):
        label += f"\\n{type(node.op).__name__}"

    graph.node(node_id, label)

    # draw an edge between current node and its parent node
    if parent is not None:
        graph.edge(parent, node_id)

    # recursively draw children of current node (draw subtrees)
    for child_name, child in ast.iter_fields(node):
        if isinstance(child, ast.AST):
            build_ast_graph(child, graph, node_id)
        elif isinstance(child, list):
            for item in child:
                if isinstance(item, ast.AST):
                    build_ast_graph(item, graph, node_id)

    return graph


def viz_ast(filename, ast_node):
    graph = build_ast_graph(ast_node)
    graph.render(filename, format='png', cleanup=True)


def viz_cfg(blocks):
    """
    Args:
        blocks: Basic blocks generated by Numba (in SSA form)

    Returns:
        Graphviz graph representing the CFG
    """
    # This is function is provided by Numba
    cfg = compute_cfg_from_blocks(blocks)

    graph = graphviz.Digraph("ControlFlowGraph")

    # Add nodes (basic blocks)
    for block_offset, block in blocks.items():
        block_label = f"Block {block_offset}\\n"
        block_label += "\\n".join([str(stmt) for stmt in block.body])
        graph.node(str(block_offset), label=block_label, shape="box")

    # Add edges (control flow between blocks)
    for block_offset, _ in blocks.items():
        for succ, _ in cfg.successors(block_offset):
            graph.edge(str(block_offset), str(succ))

    # Render and display
    graph.render('cfg', format='png', cleanup=True)
    return graph
